Absolutely. Below is a clean, idiomatic Rust conversion of the heuristic rules into enums + static tables, designed to be:

fast (no regex compilation per file)

data-driven (easy to tune)

explainable (signals preserved)

testable (pure functions)

This is copy-pasteable foundation code.

1. Core enums (roles, signals)
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Role {
    Prod,
    Test(TestKind),
    Infra,
    Docs,
    Config,
    Generated,
    Vendor,
    Scripts,
    Examples,
    Deprecated,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TestKind {
    Unit,
    Integration,
    E2E,
    Contract,
    Fixture,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Signal {
    Path,
    Filename,
    Extension,
    Neighborhood,
    Header,
    Override,
}

2. Scoring container
use std::collections::HashMap;

#[derive(Debug, Default)]
pub struct RoleScore {
    pub weights: HashMap<Role, f32>,
    pub signals: HashMap<Role, Vec<Signal>>,
}

impl RoleScore {
    pub fn add(&mut self, role: Role, weight: f32, signal: Signal) {
        *self.weights.entry(role.clone()).or_insert(0.0) += weight;
        self.signals.entry(role).or_default().push(signal);
    }
}

3. Path-based heuristic table
pub struct PathRule {
    pub fragment: &'static str,
    pub role: Role,
    pub weight: f32,
}

pub static PATH_RULES: &[PathRule] = &[
    PathRule { fragment: "/test/", role: Role::Test(TestKind::Unit), weight: 0.60 },
    PathRule { fragment: "/tests/", role: Role::Test(TestKind::Unit), weight: 0.60 },
    PathRule { fragment: "/__tests__/", role: Role::Test(TestKind::Unit), weight: 0.60 },
    PathRule { fragment: "/spec/", role: Role::Test(TestKind::Unit), weight: 0.55 },
    PathRule { fragment: "/infra/", role: Role::Infra, weight: 0.65 },
    PathRule { fragment: "/terraform/", role: Role::Infra, weight: 0.65 },
    PathRule { fragment: "/pulumi/", role: Role::Infra, weight: 0.65 },
    PathRule { fragment: "/helm/", role: Role::Infra, weight: 0.65 },
    PathRule { fragment: "/.github/workflows/", role: Role::Infra, weight: 0.70 },
    PathRule { fragment: "/docs/", role: Role::Docs, weight: 0.65 },
    PathRule { fragment: "/config/", role: Role::Config, weight: 0.55 },
    PathRule { fragment: "/scripts/", role: Role::Scripts, weight: 0.55 },
    PathRule { fragment: "/examples/", role: Role::Examples, weight: 0.55 },
    PathRule { fragment: "/vendor/", role: Role::Vendor, weight: 0.90 },
    PathRule { fragment: "/node_modules/", role: Role::Vendor, weight: 0.90 },
];

4. Filename pattern table (string matching, not regex yet)
pub struct FilenameRule {
    pub pattern: &'static str,
    pub role: Role,
    pub weight: f32,
}

pub static FILENAME_RULES: &[FilenameRule] = &[
    FilenameRule { pattern: "_test.", role: Role::Test(TestKind::Unit), weight: 0.75 },
    FilenameRule { pattern: ".spec.", role: Role::Test(TestKind::Unit), weight: 0.70 },
    FilenameRule { pattern: ".e2e.", role: Role::Test(TestKind::E2E), weight: 0.80 },
    FilenameRule { pattern: ".integration.", role: Role::Test(TestKind::Integration), weight: 0.80 },
    FilenameRule { pattern: "_fixture.", role: Role::Test(TestKind::Fixture), weight: 0.60 },
    FilenameRule { pattern: "Dockerfile", role: Role::Infra, weight: 0.85 },
    FilenameRule { pattern: "docker-compose", role: Role::Infra, weight: 0.80 },
    FilenameRule { pattern: "Makefile", role: Role::Infra, weight: 0.65 },
    FilenameRule { pattern: ".tf", role: Role::Infra, weight: 0.90 },
    FilenameRule { pattern: ".tfvars", role: Role::Infra, weight: 0.90 },
    FilenameRule { pattern: "helmfile", role: Role::Infra, weight: 0.85 },
    FilenameRule { pattern: ".env", role: Role::Config, weight: 0.85 },
    FilenameRule { pattern: "config.", role: Role::Config, weight: 0.60 },
];

5. Extension bias table (weak signal)
pub struct ExtensionRule {
    pub ext: &'static str,
    pub role: Role,
    pub weight: f32,
}

pub static EXTENSION_RULES: &[ExtensionRule] = &[
    ExtensionRule { ext: "md", role: Role::Docs, weight: 0.20 },
    ExtensionRule { ext: "mdx", role: Role::Docs, weight: 0.20 },
    ExtensionRule { ext: "yaml", role: Role::Config, weight: 0.15 },
    ExtensionRule { ext: "yml", role: Role::Config, weight: 0.15 },
    ExtensionRule { ext: "json", role: Role::Config, weight: 0.10 },
    ExtensionRule { ext: "lock", role: Role::Generated, weight: 0.90 },
    ExtensionRule { ext: "proto", role: Role::Docs, weight: 0.40 }, // interface bias
];

6. Header probe table (optional, capped)
pub struct HeaderRule {
    pub needle: &'static str,
    pub role: Role,
    pub weight: f32,
}

pub static HEADER_RULES: &[HeaderRule] = &[
    HeaderRule { needle: "Code generated by", role: Role::Generated, weight: 0.95 },
    HeaderRule { needle: "DO NOT EDIT", role: Role::Generated, weight: 0.90 },
    HeaderRule { needle: "terraform {", role: Role::Infra, weight: 0.80 },
    HeaderRule { needle: "describe(", role: Role::Test(TestKind::Unit), weight: 0.60 },
    HeaderRule { needle: "test(", role: Role::Test(TestKind::Unit), weight: 0.60 },
];

7. Applying rules (example function)
pub fn apply_path_rules(path: &str, score: &mut RoleScore) {
    let p = path.to_lowercase();
    for rule in PATH_RULES {
        if p.contains(rule.fragment) {
            score.add(rule.role.clone(), rule.weight, Signal::Path);
        }
    }
}


Equivalent helpers exist for filename, extension, header.

8. Role resolution (final selection)
pub fn resolve_role(score: &RoleScore) -> Option<(Role, f32, Vec<Signal>)> {
    let mut ranked: Vec<_> = score.weights.iter().collect();
    ranked.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());

    let (top_role, top_weight) = ranked.first()?;
    let mut confidence = *top_weight;

    if ranked.len() > 1 {
        let second_weight = ranked[1].1;
        if (top_weight - second_weight) < 0.15 {
            confidence *= 0.8; // ambiguity penalty
        }
    }

    let signals = score.signals.get(*top_role).cloned().unwrap_or_default();

    let agreement_factor = (signals.len() as f32 * 0.25).min(1.0);
    confidence = (confidence * agreement_factor).min(1.0);

    Some(((*top_role).clone(), confidence, signals))
}

9. Why this design works well in Rust

Enums enforce semantic correctness

Static tables are cache-friendly

Easy to unit-test every rule

Adding a heuristic = adding a row

JSON serialization is automatic

Renderers stay pure
